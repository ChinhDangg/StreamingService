events {}

http {

    # Use Docker‚Äôs internal DNS server (127.0.0.11) for name lookups.
    resolver 127.0.0.11 ipv6=off;

    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;;";

    # Allocate 1MB for storing keys
    lua_shared_dict jwks_cache 1m;

    # Strict for login
    limit_req_zone $binary_remote_addr zone=login_zone:10m rate=5r/m;

    # General API rate limit
    limit_req_zone $binary_remote_addr zone=api_zone:20m rate=30r/s;

    # Streaming (HLS video .ts segments)
    limit_req_zone $binary_remote_addr zone=stream_zone:50m rate=150r/s;

    # Upload endpoints (very strict)
    limit_req_zone $binary_remote_addr zone=upload_zone:10m rate=2r/m;


    upstream minio {
        server minio:9000;
    }

    server {
        listen 80;

        # for uploading images - thumbnail
        client_max_body_size 0;

        # =====================================
        # üé¨ Transcoded album video (RAM, from ffmpeg)
        # =====================================
        # Example URIs:
        # Handles /stream/album-vid/<albumId>/<resolution>/<vidNum>/<resolution>/...
        location ~ ^/stream/album-vid/([^/]+)/([^/]+)/([^/]+)/([^/]+)/(.*)$ {
            # $1 = albumId, $2 = album resolution $3 = vidNum, $4 = video resolution, $5 = rest of file path
            rewrite_by_lua_block {
                local http = require("resty.http")
                local albumId = ngx.var[1]
                local albumRes = ngx.var[2]
                local vidNum = ngx.var[3]
                local vidRes = ngx.var[4]

                -- fire-and-forget async HTTP call to Spring Boot
                ngx.timer.at(0, function()
                    local client = http.new()
                    local url = string.format("http://host.docker.internal:8080/internal/access/album-vid/%s/%s/%s/%s", albumId, albumRes, vidNum, vidRes)
                    local res, err = client:request_uri(url, {
                        method = "POST",
                        keepalive_timeout = 5,
                        keepalive_pool = 10,
                    })
                    if not res then
                        ngx.log(ngx.ERR, "Failed to notify Spring Boot access: ", err)
                    end
                end)
            }

            access_by_lua_file "/usr/local/openresty/nginx/lua/auth.lua";
            limit_req zone=stream_zone burst=500 nodelay;
            alias /chunks/$1/$3/$4/$5;
            add_header X-Origin "RAM (ffmpeg)" always;
            add_header X-Debug-Path $request_filename always;
        }


        # =====================================
        # üé¨ Transcoded image (RAM, from ffmpeg)
        # =====================================
        # Example URIs:
        # Handles /stream/album/<albumId>/<resolution>/...
        location ~ ^/stream/album/([^/]+)/([^/]+)/(.*)$ {
            # $1 = albumId, $2 = resolution, $3 = rest of file path
            rewrite_by_lua_block {
                local http = require("resty.http")
                local albumId = ngx.var[1]
                local albumRes = ngx.var[2]

                -- fire-and-forget async HTTP call to Spring Boot
                ngx.timer.at(0, function()
                    local client = http.new()
                    local url = string.format("http://host.docker.internal:8080/internal/access/album/%s/%s", albumId, albumRes)
                    local res, err = client:request_uri(url, {
                        method = "POST",
                        keepalive_timeout = 5,
                        keepalive_pool = 10,
                    })
                    if not res then
                        ngx.log(ngx.ERR, "Failed to notify Spring Boot access: ", err)
                    end
                end)
            }

            access_by_lua_file "/usr/local/openresty/nginx/lua/auth.lua";
            limit_req zone=stream_zone burst=300 nodelay;
            alias /chunks/$1/$2/$3;
            add_header X-Origin "RAM (ffmpeg)" always;
            add_header X-Debug-Path $request_filename always;
        }


        # =====================================
        # üé¨ Transcoded video (RAM, from ffmpeg)
        # =====================================
        # Example URIs:
        # Handles /stream/<videoId>/<resolution>/...
        location ~ ^/stream/([^/]+)/([^/]+)/(.*)$ {
            # $1 = videoId, $2 = resolution, $3 = rest of file path
            rewrite_by_lua_block {
                local http = require("resty.http")
                local videoId = ngx.var[1]
                local resolution = ngx.var[2]

                -- fire-and-forget async HTTP call to Spring Boot
                ngx.timer.at(0, function()
                    local client = http.new()
                    local url = string.format("http://host.docker.internal:8080/internal/access/video/%s/%s", videoId, resolution)
                    local res, err = client:request_uri(url, {
                        method = "POST",
                        keepalive_timeout = 5,
                        keepalive_pool = 10,
                    })
                    if not res then
                        ngx.log(ngx.ERR, "Failed to notify Spring Boot access: ", err)
                    end
                end)
            }

            access_by_lua_file "/usr/local/openresty/nginx/lua/auth.lua";
            limit_req zone=stream_zone burst=500 nodelay;
            alias /chunks/$1/$2/$3;
            add_header X-Origin "RAM (ffmpeg)" always;
            add_header X-Debug-Path $request_filename always;
        }


        # Use cached resized thumbnail images
        location /thumbnail-cache/ {
            access_by_lua_file "/usr/local/openresty/nginx/lua/auth.lua";
            limit_req zone=stream_zone burst=500 nodelay;
            alias /chunks/thumbnail-cache/;
            add_header X-Origin "Thumbnail-Cache" always;
            autoindex off;
        }

        # =====================================
        # üñº Original / Images directly from MinIO
        # =====================================
        # Client URL:  /images/minio/<bucket>/<object>?X-Amz-...
        # Proxies to:  http://minio:9000/<bucket>/<object>?X-Amz-...
        # =====================================
        # üéû Original / res video (MinIO)
        # =====================================
        # MinIO via Nginx (preserve signed URL)
        # Client URL:  /stream/minio/<bucket>/<object>?X-Amz-...
        # Proxies to:  http://minio:9000/<bucket>/<object>?X-Amz-...
        # strip /stream/minio/ and preserve the signed query string (X-Amz-*) ‚Äúprefix match, and stop searching‚Äù
        location ^~ /stream/minio/ {

            limit_req zone=stream_zone burst=500 nodelay;
            # trailing slash here REPLACES the matched prefix with "/"
            proxy_pass http://minio/;
            # Host header must match what presigned with
            # (use localhost:9000 if Spring Boot signed against http://localhost:9000)
            proxy_set_header Host localhost:9000;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            add_header X-Origin "MinIO";
        }

        # =====================================
        # üö´ Fallback / deny
        # =====================================
        location /stream/ {
            return 404;
        }

        # =====================================
        # üåê Spring Boot API
        # =====================================
        # If Spring Boot runs *outside* Docker on host machine
        location /api/upload/ {
            limit_req zone=upload_zone burst=5 nodelay;
            proxy_pass http://host.docker.internal:8083;
            proxy_set_header Host $host;
            proxy_set_header X-XSRF-TOKEN $http_x_xsrf_token;
        }

        location /api/modify/ {
            limit_req zone=upload_zone burst=10 nodelay;
            proxy_pass http://host.docker.internal:8083;
            proxy_set_header Host $host;
            proxy_set_header X-XSRF-TOKEN $http_x_xsrf_token;
        }

        location /api/ {
            limit_req zone=api_zone burst=50 nodelay;
            proxy_pass http://host.docker.internal:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-XSRF-TOKEN $http_x_xsrf_token;
        }

        location /auth/ {
            limit_req zone=login_zone burst=10 nodelay;
            proxy_pass http://host.docker.internal:8084;
            proxy_set_header Host $host;
            proxy_set_header X-XSRF-TOKEN $http_x_xsrf_token;
        }

        location /page/ {
            limit_req zone=api_zone burst=50 nodelay;
            proxy_pass http://host.docker.internal:8081;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location /static/ {
            limit_req zone=api_zone burst=100 nodelay;
            proxy_pass http://host.docker.internal:8081;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location / {
            limit_req zone=api_zone burst=50 nodelay;
            proxy_pass http://host.docker.internal:8081;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # If later add Spring Boot into docker-compose, switch to:
        # location /api/ {
        #     proxy_pass http://springboot:8080;
        #     proxy_set_header Host $host;
        #     proxy_set_header X-Real-IP $remote_addr;
        # }

    }
}
