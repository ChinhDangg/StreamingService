events {}

http {

    # Use Docker‚Äôs internal DNS server (127.0.0.11) for name lookups.
    resolver 127.0.0.11 valid=30s ipv6=off;

    upstream minio {
        server minio:9000;
    }

    server {
        listen 80;


        location ~ ^/stream/album-vid/([^/]+)/([^/]+)/([^/]+)/(.*)$ {
            # $1 = albumId, $2 = vidNum, $3 = resolution, $4 = rest of file path
            access_by_lua_block {
                local http = require("resty.http")
                local albumId = ngx.var[1]
                local vidNum = ngx.var[2]
                local resolution = ngx.var[3]

                -- fire-and-forget async HTTP call to Spring Boot
                ngx.timer.at(0, function()
                    local client = http.new()
                    local url = string.format("http://host.docker.internal:8080/internal/access/album-parital/%s/%s/%s", albumId, vidNum, resolution)
                    local res, err = client:request_uri(url, {
                        method = "POST",
                        keepalive_timeout = 5,
                        keepalive_pool = 10,
                    })
                    if not res then
                        ngx.log(ngx.ERR, "Failed to notify Spring Boot access: ", err)
                    end
                end)
            }

            alias /chunks/$1/$2/$3/$4;
            add_header X-Origin "RAM (ffmpeg)" always;
            add_header X-Debug-Path $request_filename always;
        }


        # =====================================
        # üé¨ Transcoded video (RAM, from ffmpeg)
        # =====================================
        # Example URIs:
        # Handles /stream/<videoId>/<resolution>/...
        location ~ ^/stream/([^/]+)/([^/]+)/(.*)$ {
            # $1 = videoId, $2 = resolution, $3 = rest of file path
            access_by_lua_block {
                local http = require("resty.http")
                local videoId = ngx.var[1]
                local resolution = ngx.var[2]

                -- fire-and-forget async HTTP call to Spring Boot
                ngx.timer.at(0, function()
                    local client = http.new()
                    local url = string.format("http://host.docker.internal:8080/internal/access/parital/%s/%s", videoId, resolution)
                    local res, err = client:request_uri(url, {
                        method = "POST",
                        keepalive_timeout = 5,
                        keepalive_pool = 10,
                    })
                    if not res then
                        ngx.log(ngx.ERR, "Failed to notify Spring Boot access: ", err)
                    end
                end)
            }

            alias /chunks/$1/$2/$3;
            add_header X-Origin "RAM (ffmpeg)" always;
            add_header X-Debug-Path $request_filename always;
        }


        # Use cached resized thumbnail images
        location /thumbnail-cache/ {
            alias /chunks/thumbnail-cache/;
            autoindex off;
        }

        # =====================================
        # üñº Original / Images directly from MinIO
        # =====================================
        # Client URL:  /images/minio/<bucket>/<object>?X-Amz-...
        # Proxies to:  http://minio:9000/<bucket>/<object>?X-Amz-...
        # =====================================
        # üéû Original / res video (MinIO)
        # =====================================
        # MinIO via Nginx (preserve signed URL)
        # Client URL:  /stream/minio/<bucket>/<object>?X-Amz-...
        # Proxies to:  http://minio:9000/<bucket>/<object>?X-Amz-...
        # strip /stream/minio/ and preserve the signed query string (X-Amz-*) ‚Äúprefix match, and stop searching‚Äù
        location ^~ /stream/minio/ {
            # trailing slash here REPLACES the matched prefix with "/"
            proxy_pass http://minio/;

            # Host header must match what you presigned with
            # (use localhost:9000 if Spring Boot signed against http://localhost:9000)
            proxy_set_header Host localhost:9000;

            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            add_header X-Origin "MinIO";
        }

        # =====================================
        # üö´ Fallback / deny
        # =====================================
        location /stream/ {
            return 404;
        }

        # =====================================
        # üåê Spring Boot API
        # =====================================
        # If Spring Boot runs *outside* Docker on your host machine
        location /api/ {
            proxy_pass http://host.docker.internal:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location /page/ {
            proxy_pass http://host.docker.internal:8081;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # If you later add Spring Boot into docker-compose, switch to:
        # location /api/ {
        #     proxy_pass http://springboot:8080;
        #     proxy_set_header Host $host;
        #     proxy_set_header X-Real-IP $remote_addr;
        # }

    }
}
