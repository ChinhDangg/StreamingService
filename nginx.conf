events {}

http {

    lua_shared_dict watchers 10m;

    upstream minio {
        server minio:9000;
    }

    server {
        listen 80;

        # =====================================
        # ðŸŽ¬ Transcoded video (RAM, from ffmpeg)
        # =====================================
        # Example URIs:
        # Handles /stream/<videoId>/<resolution>/partial/...
        location ~ ^/stream/([^/]+)/([^/]+)/partial/(.*)$ {
            # $1 = videoId, $2 = resolution, $3 = rest of file path
            access_by_lua_block {
                local watchers = ngx.shared.watchers
                local key = ngx.var[1] .. "::" .. ngx.var[2] # key = "1::p360"
                watchers:set(key, ngx.now())
            }

            alias /chunks/$1/$2/partial/$3;
            add_header X-Origin "RAM (ffmpeg)" always;
            add_header X-Debug-Path $request_filename always;
        }

        # ðŸ”¹ Preview (10% trailer @ 360p)
        location ~ ^/stream/([^/]+)/preview/(.*)$ {
            alias /chunks/$1/preview/$2;
            add_header X-Origin "RAM (ffmpeg, preview)" always;
        }

        # =====================================
        # ðŸ–¼ Images directly from MinIO
        # =====================================
        # Client URL:  /images/minio/<bucket>/<object>?X-Amz-...
        # Proxies to:  http://minio:9000/<bucket>/<object>?X-Amz-...
        # =====================================
        # ðŸŽž Original / high-res video (MinIO)
        # =====================================
        # MinIO via Nginx (preserve signed URL)
        # Client URL:  /stream/minio/<bucket>/<object>?X-Amz-...
        # Proxies to:  http://minio:9000/<bucket>/<object>?X-Amz-...
        # strip /stream/minio/ and preserve the signed query string (X-Amz-*)
        location ^~ /stream/minio/ {
            # trailing slash here REPLACES the matched prefix with "/"
            proxy_pass http://minio/;

            # Host header must match what you presigned with
            # (use localhost:9000 if Spring Boot signed against http://localhost:9000)
            proxy_set_header Host localhost:9000;

            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            add_header X-Origin "MinIO";
        }

        # Use cached resized images
        location /cache/ {
            alias /chunks/image-cache/;
            autoindex off;
            add_header Cache-Control "public, max-age=3600";
        }

        # =====================================
        # ðŸš« Fallback / deny
        # =====================================
        location /stream/ {
            return 404;
        }

        # =====================================
        # ðŸŒ Spring Boot API
        # =====================================
        # If Spring Boot runs *outside* Docker on your host machine
        location /api/ {
            proxy_pass http://host.docker.internal:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location /page/ {
            proxy_pass http://host.docker.internal:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # If you later add Spring Boot into docker-compose, switch to:
        # location /api/ {
        #     proxy_pass http://springboot:8080;
        #     proxy_set_header Host $host;
        #     proxy_set_header X-Real-IP $remote_addr;
        # }


        # List active watchers
        location = /internal/watchers {
            content_by_lua_block {
                local watchers = ngx.shared.watchers
                local keys = watchers:get_keys(0)
                local data = {}
                for _, k in ipairs(keys) do
                    data[k] = watchers:get(k)
                end
                ngx.header.content_type = "application/json"
                ngx.say(require("cjson").encode(data))
            }
            allow 127.0.0.1;
            allow ::1;
            allow 172.17.0.0/16;   # Docker internal bridge network range
            allow 172.20.0.0/16;   # your actual Docker subnet (from the log)
            deny all;
        }

        # Cleanup endpoint
        location = /internal/cleanup_watchers {
            content_by_lua_block {
                local watchers = ngx.shared.watchers
                local timeout = tonumber(ngx.var.arg_timeout) or 20
                local now = ngx.now()
                local removed = {}

                for _, key in ipairs(watchers:get_keys(0)) do
                    local last = watchers:get(key)
                    if last and now - last > timeout then
                        watchers:delete(key)
                        table.insert(removed, key)
                    end
                end

                ngx.header.content_type = "application/json"
                ngx.say(require("cjson").encode({
                    removed = removed,
                    timeout = timeout
                }))
            }
            allow 127.0.0.1;
            allow ::1;
            allow 172.17.0.0/16;   # Docker internal bridge network range
            allow 172.20.0.0/16;   # your actual Docker subnet (from the log)
            deny all;
        }

        location = /internal/debug_ip {
            default_type text/plain;
            return 200 "Your IP: $remote_addr\n";
        }
    }
}
